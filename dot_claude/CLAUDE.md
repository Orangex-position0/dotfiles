# CLAUDE.md 

## 第一部分：核心编程原则 (Guiding Principles)
这是我们合作的顶层思想，指导所有具体的行为。

### 基础设计原则
- **可读性优先 (Readability First)：** 始终牢记"代码是写给人看的，只是恰好机器可以执行"。清晰度高于一切。
- **DRY (Don't Repeat Yourself)：** 绝不复制代码片段。通过抽象（如函数、类、模块）来封装和复用通用逻辑。
- **高内聚，低耦合 (High Cohesion, Low Coupling)：** 功能高度相关的代码应该放在一起（高内聚），而模块之间应尽量减少依赖（低耦合），以增强模块独立性和可维护性。

### DDD架构
- **领域驱动设计 (Domain-Driven Design)：** 采用 Domain Model（领域模型）并结合 SOLID 设计原则，以业务领域为核心组织代码结构。
- **渐进式开发策略：** 每写一个单元就进行一轮测试，避免后期全局修改和发现系统性问题。
- **领域边界清晰：** 通过明确的 domain 关系对应，减少设计偏差和架构混乱。
- **AI 辅助质量保障：** 结合 AI 工具提升软件设计和技术管理的标准，但核心的设计决策和质量把控仍需人工判断。

## 第二部分：具体执行指令 (Actionable Instructions)
这是 Claude 在日常工作中需要严格遵守的具体操作指南。
沟通与语言规范:
- 默认语言：请默认使用简体中文进行所有交流、解释和思考过程的陈述。
代码与术语：所有代码实体（变量名、函数名、类名等）及技术术语（如库名、框架名、设计模式等）必须保持英文原文。
- 注释规范：代码注释应使用中文。
- 行尾注释禁令 (End-of-Line Comment Prohibition)：严格禁止在代码行末尾添加注释（如 `code; // 注释`）。所有注释必须单独占行或作为方法/类的头部注释。这确保代码的简洁性和可读性，避免行尾注释造成的视觉干扰。
- 批判性反馈与破框思维 (Critical Feedback & Out-of-the-Box Thinking)：
- 审慎分析：必须以审视和批判的眼光分析我的输入，主动识别潜在的问题、逻辑谬误或认知偏差。
- 坦率直言：需要明确、直接地指出我思考中的盲点，并提供显著超越我当前思考框架的建议，以挑战我的预设。
- 严厉质询 (Tough Questioning)：当我提出的想法或方案明显不合理、过于理想化或偏离正轨时，必须使用更直接、甚至尖锐的言辞进行反驳和质询，帮我打破思维定式，回归理性。
开发与调试策略 (Development & Debugging Strategy)

### 问题解决策略
- **坚韧不拔的解决问题 (Tenacious Problem-Solving)：** 当面对编译错误、逻辑不通或多次尝试失败时，绝不允许通过简化或伪造实现来"绕过"问题。
- **逐个击破 (Incremental Debugging)：** 必须坚持对错误和问题进行逐一分析、定位和修复。
- **探索有效替代方案 (Explore Viable Alternatives)：** 如果当前路径确实无法走通，应切换到另一个逻辑完整、功能健全的替代方案来解决问题，而不是退回到一个简化的、虚假的版本。
- **禁止伪造实现 (No Fake Implementations)：** 严禁使用占位符逻辑（如空的循环）、虚假数据或不完整的函数来伪装功能已经实现。所有交付的代码都必须是意图明确且具备真实逻辑的。
- **战略性搁置 (Strategic Postponement)：** 只有当一个问题被证实非常困难，且其当前优先级不高时，才允许被暂时搁置。搁置时，必须以 TODO 形式在代码中或任务列表中明确标记，并清晰说明遇到的问题。在核心任务完成后，必须回过头来重新审视并解决这些被搁置的问题。

### AI 辅助开发指导原则
- **AI 工具定位：** AI 应作为开发效率的倍增器，而非替代开发者的决策能力。AI 擅长代码生成、重构建议和错误检测，但核心的架构设计和业务逻辑判断仍需人工把控。
- **质量标准提升：** 使用 AI 辅助开发要求更高的软件设计和技术管理标准，因为 AI 生成的代码需要更严格的审查和验证。
- **代码审查强化：** 对 AI 生成的代码必须进行全面的人工审查，特别关注业务逻辑的正确性、安全性和性能表现。
- **持续学习：** 开发者应该从 AI 的建议中学习最佳实践，同时教会 AI 项目特定的约定和模式。
- **工具链整合：** 将 AI 工具有机集成到现有的开发流程中，包括代码补全、测试生成、文档编写等环节。

项目与代码维护 (Project & Code Maintenance)
- **统一文档维护 (Unified Documentation Maintenance)：** 严禁为每个独立任务（如重构、功能实现）创建新的总结文档（例如 CODE_REFACTORING_SUMMARY.md）。在任务完成后，必须优先检查项目中已有的相关文档（如 README.md、既有的设计文档等），并将新的总结、变更或补充内容直接整合到现有文档中，维护其完整性和时效性。
- **及时清理 (Timely Cleanup)：** 在完成开发任务时，如果发现任何已无用（过时）的代码、文件或注释，应主动提出清理建议。


## 第三部分：项目架构指南(Project Architecture Manual)
先判断项目是否属于这其中的某个架构，再决定是否使用该指南。

### 领域驱动设计 (DDD) 实施指南

#### 领域模型组织
- **领域边界划分：** 根据业务领域划分有界上下文（Bounded Context），每个上下文内部保持概念的一致性
- **领域对象设计：** 
  - **实体(Entity)：** **具有唯一标识的对象**，用于表达领域中的核心业务概念。实体 = 唯一标识 + 状态属性 + 行为动作（功能），常位于 `model/eneity/` 目录下。
  - **值对象 (Value Object)：** 用于描述领域的某个方面但**无独立身份标识的对象**，通常用于配合实体对象使用，减少Entity的关联性，常位于 `model/valobj/` 目录下。
  - **聚合根 (Aggregate Root)：** 作为聚合的入口点，确保业务规则的一致性。
  - **领域服务 (Domain Service)：** 封装无法归属到特定实体的业务逻辑，存放处理领域逻辑的组件，用于协调Entity 和 Value Object之间的操作。

#### 分层架构实现
- **接口定义-api** ：因为微服务中引用的 RPC 需要对外提供接口的描述信息，也就是调用方在使用的时候，需要引入 Jar 包，让调用方好能依赖接口的定义做代理。
	- http接口依赖倒置：将Controller层的http请求接口定义在api层，而Trigger层提供具体实现。API层（接口定义）→ Trigger层（具体实现）→ Domain层（业务逻辑）。
	- DTO对象：供http接口使用
- **应用封装-app** ：这是应用启动和配置的一层，如一些 aop 切面或者 config 配置，以及打包镜像都是在这一层处理。你可以把它理解为专门为了启动服务而存在的。
	- 存放配置文件：如 `application.yml` 文件，Redis配置类等
	- 存放mapper文件：如mybatis的 `mapper.xml` 文件
- **领域封装-domain** ：领域模型服务，在一层中会有一个个细分的领域服务，在每个服务包中会有【model、repository、service】3部分。
	- model：存放entity、valobj、aggregate
	- repository：定义仓储接口，实现类写在infrastructure中
	- service：编写领域核心业务逻辑
- **仓储服务-infrastructure** ：基础层依赖于 domain 领域层，因为在 domain 层定义的仓储接口需要在基础层实现。这是**依赖倒置**的一种设计方式。
	- dao包：存Dao接口
	- po包：存po对象
	- repository：编写domain中仓储接口的实现类
- **触发操作-trigger** ：触发器层，用于提供接口实现、消息接收、任务执行等。所以对于这样的操作，小傅哥把它叫做触发器层。
	- http：编写api中http接口的实现类作为Controller层
	- job：编写定时任务
	- listener：编写消息队列相关逻辑
- **类型定义-types** ：通用类型定义层，在我们的系统开发中，会有很多类型的定义，包括；基本的 Response、Constants 和枚举。它会被其他的层进行引用使用。
	- Constants：常量定义
	- ResponseCode：统一响应
	- AppException：自定义异常类
	- ResponseCode：响应码枚举
	- BaseEvent：基础事件抽象类
- **领域编排-case（可选）**：对于较大且复杂的项目，为了防腐和提供通用服务，一般会用case层对domain领域的逻辑进行封装组合处理

#### 统一语言 (Ubiquitous Language)
- **命名一致性：** 代码中的类名、方法名、变量名应与业务术语保持一致
- **权限命名规范：** 使用 `模块名:功能名:操作名` 格式，体现业务领域结构
- **文档同步：** 确保代码、文档和业务人员使用相同的术语

#### 领域事件处理
- **事件驱动架构：** 通过领域事件实现不同聚合之间的松耦合通信
- **事件存储：** 记录重要的业务事件，支持事件溯源和审计
- **异步处理：** 对于复杂的业务流程，使用异步事件处理提高系统性能

## 第四部分: 文档说明
### 接口文档
接口文档要满足以下条件：
- 接口名称要清晰
	- 接口名要能看出接口作用
- 接口地址是否完成
	- 接口的 URL 地址在文档中要有完整描述，包括域名、协议、端口等
- 请求参数规范
	- 接口的请求参数说明要满足规范：
		- 参数名用驼峰命名
		- 参数类型
		- 参数默认值
		- 取值范围
		- 参数格式
		- 说明请求参数是否为“必填”
		- 入参示例值
		- 参数备注
- 响应参数规范
	- 接口的响应参数说明要满足规范：
		- 参数名称
		- 参数类型
		- 参数格式
		- 取值范围
		- 说明响应参数是否为“必填”
		- 出餐示例值
- 标明请求头
	- 文档中要标明请求头有哪些
- 接口安全性说明
	- 文档要包含接口安全性说明，如接口的访问授权方式、数据传输加密方式等，还要对敏感数据进行标注
- 接口版本管理
	- 做好接口版本管理：
		- 在接口文档中声明版本号
		- 使用语义化版本号
		- 增量发布：接口变化是，先发布新版本接口，同时保留旧版本接口，后续逐步替换旧接口
- 文档更新记录
	- 接口文档的更新要有对应的变更记录
